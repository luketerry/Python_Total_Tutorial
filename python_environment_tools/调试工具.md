
# è°ƒè¯•å·¥å…·

## è°ƒè¯•æ¨¡å—
pdbæ˜¯pythonè‡ªå¸¦çš„è°ƒè¯•æ¨¡å—,å®ƒå¯ä»¥åœ¨äº¤äº’ç¯å¢ƒä¸­ä½¿ç”¨,ä¹Ÿå¯ä»¥åœ¨terminalä¸­ä½œä¸ºpythonçš„ä¸€ä¸ªæ¨¡å¼ä½¿ç”¨

> è¦è°ƒè¯•çš„è„šæœ¬:


```python
%%writefile counter.py
#!/usr/bin/env python
# --*-- coding:utf-8 --*--
from __future__ import print_function

class Counter(object):
    """ä¸€ä¸ªè®¡æ•°å™¨
    ç”¨æ³•:
    >>> counter1 = Counter()
    >>> counter1()
    1
    >>> counter1()
    2
    >>> counter2 = Counter(lambda : 2,-3)
    >>> counter2()
    -1
    >>> counter2()
    1
    """
    def __str__(self):
        return "state:"+str(self.value)
    def __repr__(self):
        return self.__str__
    def __call__(self):
        def count():
            self.value += self.func()
            return self.value
        return count()
    
    def __init__(self,func=lambda : 1,start=0):
        self.value = start
        self.func = func 
test = Counter()
test()
test()
print(test)
if __name__=="__main__":
    counter1 = Counter()
    counter2 = Counter()
    for i in range(10):
        counter1()
    for i in range(8):
        counter2()
    if counter1.value == counter2.value:
        print("not success")
    else: 
        print("don't known")
        
    
    import doctest
    doctest.testmod(verbose=True)

```

    Writing counter.py


> å‘½ä»¤è¡Œè°ƒè¯•

    python -m pdb counter.py
    
åœ¨jupyterä¸­æ— æ³•æ¼”ç¤º,è¯·è‡ªå·±è¯•è¯•

> åœ¨äº¤äº’shellä¸­è°ƒè¯•

    import pdb
    import counter
    pdb.run('counter.test()')

> å¸¸ç”¨çš„è°ƒè¯•å‘½ä»¤

å¯ä»¥ç”¨helpå‘½ä»¤æ¥æŸ¥çœ‹

> åœ¨ipythonä¸­è°ƒç”¨pdb

ipythonå†…ç½®äº†é­”æ³•å‘½ä»¤`%pdb`å¯ä»¥åœ¨ç¨‹åºå‡ºé”™çš„æ—¶å€™è‡ªåŠ¨è·³å…¥debug


```python
%pdb
from __future__ import print_function

class Counter(object):
    """ä¸€ä¸ªè®¡æ•°å™¨
    ç”¨æ³•:
    >>> counter1 = Counter()
    >>> counter1()
    1
    >>> counter1()
    2
    >>> counter2 = Counter(lambda : 2,-3)
    >>> counter2()
    -1
    >>> counter2()
    1
    """
    def __str__(self):
        return "state:"+str(self.value)
    def __repr__(self):
        return self.__str__
    def __call__(self):
        def count():
            self.value += self.func()
            return self.value
        return count()
    
    def __init__(self,func=lambda : 1,start=0):
        self.value = start
        self.func = func 
test = Counter()
test()
test()
print(test)
assert test.value == 1 
```

    Automatic pdb calling has been turned ON
    state:2



    ---------------------------------------------------------------------------

    AssertionError                            Traceback (most recent call last)

    <ipython-input-2-16cc623a427d> in <module>()
         33 test()
         34 print(test)
    ---> 35 assert test.value == 1
    

    AssertionError: 


    > [0;32m<ipython-input-2-16cc623a427d>[0m(35)[0;36m<module>[0;34m()[0m
    [0;32m     31 [0;31m[0mtest[0m [0;34m=[0m [0mCounter[0m[0;34m([0m[0;34m)[0m[0;34m[0m[0m
    [0m[0;32m     32 [0;31m[0mtest[0m[0;34m([0m[0;34m)[0m[0;34m[0m[0m
    [0m[0;32m     33 [0;31m[0mtest[0m[0;34m([0m[0;34m)[0m[0;34m[0m[0m
    [0m[0;32m     34 [0;31m[0mprint[0m[0;34m([0m[0mtest[0m[0;34m)[0m[0;34m[0m[0m
    [0m[0;32m---> 35 [0;31m[0;32massert[0m [0mtest[0m[0;34m.[0m[0mvalue[0m [0;34m==[0m [0;36m1[0m[0;34m[0m[0m
    [0m
    ipdb> help
    
    Documented commands (type help <topic>):
    ========================================
    EOF    c          d        h         next    pp       retval  u          whatis
    a      cl         debug    help      p       psource  run     unalias    where 
    alias  clear      disable  ignore    pdef    q        rv      undisplay
    args   commands   display  interact  pdoc    quit     s       unt      
    b      condition  down     j         pfile   r        source  until    
    break  cont       enable   jump      pinfo   restart  step    up       
    bt     continue   exit     n         pinfo2  return   tbreak  w        
    
    Miscellaneous help topics:
    ==========================
    pdb  exec
    
    Undocumented commands:
    ======================
    l  list  ll  longlist
    
    ipdb> exit


##  è°ƒç”¨è¿½è¸ª

è°ƒè¯•çš„æ—¶å€™æˆ‘ä»¬é™¤äº†æƒ³çŸ¥é“å“ªæ¡ä»£ç é”™äº†,ä¹Ÿä¼šæƒ³çŸ¥é“æ˜¯è°è°ƒç”¨äº†è¿™æ¡é”™è¯¯çš„ä»£ç ,è¿™ä¸ªæ—¶å€™è°ƒç”¨è¿½è¸ªæ¨¡å—å°±æœ‰ç”¨äº†

>ä¸€ä¸ªç®€å•çš„ä¾‹å­ 


```python
import traceback
def func():
    s =  traceback.extract_stack()
    print('%s Invoked me!'%s[-2][2])
    
def a():
    func()
b = lambda :func()
```


```python
a()
```

    a Invoked me!



```python
b()
```

    <lambda> Invoked me!


## æµ‹è¯•è¿è¡Œæ—¶é—´æ¨¡å—

Pythonä¸­çš„timeitæ˜¯æµ‹è¯•ä»£ç æ‰§è¡Œæ•ˆç‡çš„å·¥å…·.å¯ä»¥ç”¨å‘½ä»¤è¡Œç›´æ¥æµ‹è¯•è„šæœ¬,ä¹Ÿå¯ä»¥æµ‹è¯•ä»£ç å­—ç¬¦ä¸²çš„æ•ˆç‡,å½“ç„¶æœ€ç®€å•çš„è¿˜æ˜¯ç›´æ¥ç”¨ipythonçš„å†…ç½®timeité­”æ³•å‘½ä»¤æµ‹æŸæ®µä»£ç çš„æ•ˆç‡


```python
import timeit
t = timeit.Timer('map(lambda x: x**2,range(1000))')
t.timeit()
```




    1.00792034000915



åœ¨å‘½ä»¤è¡Œä¸­æˆ‘ä»¬å‘¢ä¹Ÿå¯ä»¥è¿™æ ·ä½¿ç”¨


```python
!python -m timeit -s "map(lambda x: x**2,range(1000))"
```

    10000000 loops, best of 3: 0.0225 usec per loop


åœ¨jupyterä¸­æ›´åŠ ç®€å•äº†,å¯ä»¥ä½¿ç”¨é­”æ³•å‘½ä»¤æ¥æµ‹è¯•


```python
%timeit  map(lambda x: x**2,range(1000))
```

    1000000 loops, best of 3: 930 ns per loop

